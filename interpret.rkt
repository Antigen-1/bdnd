#lang racket/base
(require "codec.rkt" "huffman.rkt" racket/file "lock.rkt" racket/class "buffer.rkt")
(provide bdnd-interpret)

(define (bdnd-interpret filelist tree prefix port size)
  (file-stream-buffer-mode port 'block)
  (let-values (((ich thd) (decompress-from-port port (cond (size) (else 1000000))))
               ((buffer) (new buffer% (size (cond (size => integer-sqrt) (else 1000))))))
    (make-directory* prefix)
    (parameterize ((current-directory prefix))
      (foldl (lambda (f i) (let ((name (cadr f))
                                 (size (car f)))
                             (collect-garbage 'incremental)
                             (with-handlers ((exn:fail:filesystem? (lambda (e) (delete-directory/files #:must-exist? #f name) (raise e))))
                               (make-parent-directory* name)
                               (call-with-output-file/lock
                                 name
                                 (lambda (out)
                                   (file-stream-buffer-mode out 'block)
                                   (send buffer set-output out)
                                   (let loop ((t tree) (l i) (s size))
                                     (define (index l)
                                       (let ((r (index-huffman-tree t l)))
                                         (if (byte? (car r))
                                             (begin (send buffer commit (car r)) (loop tree (cdr r) (sub1 s)))
                                             (loop (car r) null s))))
                                     (cond ((zero? s) (send buffer flush) l)
                                           ((null? l)
                                            (sync (handle-evt ich index)))
                                           (else (index l)))))))))
             null
             filelist))
    (sync (handle-evt thd void))))
